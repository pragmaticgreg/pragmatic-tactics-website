

<!-- Overlay SVG for Dynamic Connectors -->
<svg id="flow-lines" 
style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 0.1;" 
aria-hidden="true">
</svg>

<script>
    // Dynamic SVG Connectors for Problems Section
    const svg = document.getElementById('flow-lines');

    function drawProblemConnectors() {
        // Clear previous paths
        svg.innerHTML = '';
        
        // Update SVG dimensions to cover full document
        const fullWidth = Math.max(document.documentElement.scrollWidth, window.innerWidth);
        const fullHeight = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, window.innerHeight);
        
        svg.setAttribute('width', fullWidth);
        svg.setAttribute('height', fullHeight);
        svg.style.width = fullWidth + 'px';
        svg.style.height = fullHeight + 'px';

        // Get card elements (not icons)
        const strategicProblem = document.getElementById('0-strategic-problem');
        const problemCards = [
            document.getElementById('2-problem-plateau'),
            document.getElementById('4-problem-outcomes'), 
            document.getElementById('6-problem-toolbox')
        ];

        if (!strategicProblem || problemCards.some(card => !card)) return;

        // Calculate source position (strategic problem card bottom-center)
        const sourceRect = strategicProblem.getBoundingClientRect();
        const sourceX = sourceRect.left + sourceRect.width / 2;
        const sourceY = sourceRect.bottom; // Bottom of card instead of center

        // Create branching effect: single line down, then split to three targets
        const branchStartY = sourceY + 40; // Shortened from 60px

        // Draw the main trunk line from source card bottom down
        const trunkPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const trunkData = `M${sourceX},${sourceY} L${sourceX},${branchStartY}`;
        trunkPath.setAttribute('d', trunkData);
        trunkPath.setAttribute('fill', 'none');
        trunkPath.setAttribute('stroke', '#0f172a'); // Primary navy color
        trunkPath.setAttribute('stroke-width', '5');
        trunkPath.setAttribute('opacity', '0.8');
        trunkPath.setAttribute('stroke-linecap', 'round');
        svg.appendChild(trunkPath);

        // Draw branches to each target card
        problemCards.forEach((targetCard, index) => {
            const targetRect = targetCard.getBoundingClientRect();
            const targetX = targetRect.left + targetRect.width / 2;
            const targetY = targetRect.top; // Top of card instead of center

            // Create smooth curve from branch point to target card top
            const pathData = `M${sourceX},${branchStartY} C${sourceX},${branchStartY + (targetY - branchStartY) * 0.3} ${targetX},${targetY - (targetY - branchStartY) * 0.3} ${targetX},${targetY}`;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathData);
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', '#0f172a'); // Primary navy color
            path.setAttribute('stroke-width', '5');
            path.setAttribute('opacity', '0.8');
            path.setAttribute('stroke-linecap', 'round');
            svg.appendChild(path);
        });

        // Draw straight lines from problem cards to solution cards
        const solutionCards = [
            document.getElementById('3-solution-people'),    // Maps to problem-plateau
            document.getElementById('5-solution-process'),   // Maps to problem-outcomes  
            document.getElementById('7-solution-technology') // Maps to problem-toolbox
        ];

        if (solutionCards.every(card => card)) {
            problemCards.forEach((problemCard, index) => {
                const solutionCard = solutionCards[index];
                
                const problemRect = problemCard.getBoundingClientRect();
                const solutionRect = solutionCard.getBoundingClientRect();
                
                const startX = problemRect.left + problemRect.width / 2;
                const startY = problemRect.bottom;
                const endX = solutionRect.left + solutionRect.width / 2;
                const endY = solutionRect.top;

                // Draw straight line from problem card bottom to solution card top
                const straightPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const straightData = `M${startX},${startY} L${endX},${endY}`;
                straightPath.setAttribute('d', straightData);
                straightPath.setAttribute('fill', 'none');
                straightPath.setAttribute('stroke', '#0f172a');
                straightPath.setAttribute('stroke-width', '5');
                straightPath.setAttribute('opacity', '0.8');
                straightPath.setAttribute('stroke-linecap', 'round');
                svg.appendChild(straightPath);
            });

            // Draw branching lines from solution cards to strategic solution
            const strategicSolution = document.getElementById('9-strategic-solution');
            if (strategicSolution) {
                const strategicSolutionRect = strategicSolution.getBoundingClientRect();
                const strategicSolutionX = strategicSolutionRect.left + strategicSolutionRect.width / 2;
                const strategicSolutionY = strategicSolutionRect.top;

                // Create branching effect: lines from solution cards converge, then single line to strategic solution
                const convergenceY = strategicSolutionY - 40; // Branch point above strategic solution

                // Draw the main trunk line from convergence point to strategic solution top
                const solutionTrunkPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const solutionTrunkData = `M${strategicSolutionX},${convergenceY} L${strategicSolutionX},${strategicSolutionY}`;
                solutionTrunkPath.setAttribute('d', solutionTrunkData);
                solutionTrunkPath.setAttribute('fill', 'none');
                solutionTrunkPath.setAttribute('stroke', '#0f172a');
                solutionTrunkPath.setAttribute('stroke-width', '5');
                solutionTrunkPath.setAttribute('opacity', '0.8');
                solutionTrunkPath.setAttribute('stroke-linecap', 'round');
                svg.appendChild(solutionTrunkPath);

                // Draw branches from each solution card to the convergence point
                solutionCards.forEach((solutionCard, index) => {
                    const solutionRect = solutionCard.getBoundingClientRect();
                    const solutionX = solutionRect.left + solutionRect.width / 2;
                    const solutionY = solutionRect.bottom;

                    // Create smooth curve from solution card bottom to convergence point
                    const pathData = `M${solutionX},${solutionY} C${solutionX},${solutionY + (convergenceY - solutionY) * 0.3} ${strategicSolutionX},${convergenceY - (convergenceY - solutionY) * 0.3} ${strategicSolutionX},${convergenceY}`;

                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', pathData);
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke', '#0f172a');
                    path.setAttribute('stroke-width', '5');
                    path.setAttribute('opacity', '0.8');
                    path.setAttribute('stroke-linecap', 'round');
                    svg.appendChild(path);
                });
            }
        }
    }

    // Handle mobile display
    function handleConnectorMobileDisplay() {
        if (window.innerWidth <= 768) {
            svg.style.display = 'none';
        } else {
            svg.style.display = 'block';
            drawProblemConnectors();
        }
    }

    // Initialize connectors
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(handleConnectorMobileDisplay, 100);
        });
    } else {
        setTimeout(handleConnectorMobileDisplay, 100);
    }

    // Event listeners for reactive updates
    window.addEventListener('resize', () => {
        clearTimeout(window.connectorTimeout);
        window.connectorTimeout = setTimeout(handleConnectorMobileDisplay, 100);
    });
    
    window.addEventListener('scroll', () => {
        if (window.innerWidth > 768) {
            requestAnimationFrame(drawProblemConnectors);
        }
    });
</script>
